<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Java On Call 5 · Tao Ma</title>


<meta name="description" content="  Java基础知识  面向对象  常用API  集合I/O  多线程、网络编程、反射、设计模式">

<link rel="icon" href="http://localhost:4000/assets/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png">
<link rel="stylesheet" href="http://localhost:4000/assets/core.css">
<link rel="canonical" href="http://localhost:4000/java-on-call-5">
<link rel="alternate" type="application/atom+xml" title="Tao Ma" href="http://localhost:4000/feed.xml" />


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


	</head>

	<body>

		<aside class="logo">

	

	<a href="http://localhost:4000/">
		<img src="https://source.unsplash.com/random/460x460" alt="" class="logo-avatar">
	</a>
	<span class="logo-prompt code">Back to Index</span>
</aside>
<br />
<section>
		And hello to u too:) By clicking the above icon, u can come back to index any time, or u can eneter my personal info page. 
		<br />
		<em><strong>The picture is randomly generated every time u click the icon, I have nothing to do with any of the content of the pictures(ﾟ∀ﾟ)</strong></em>
.
</section>


		<div id="content">
			<article>

	<div class="center">
		<h1 class="title">Java On Call 5</h1>
		<time class="code">May 12, 2020</time>
	</div>

	<div class="divider"></div>

	<ol>
  <li>Java基础知识</li>
  <li>面向对象</li>
  <li>常用API</li>
  <li>集合I/O</li>
  <li>多线程、网络编程、反射、设计模式</li>
</ol>

<p>这是准备java面试的第二天，以上的分类的思维导图，来自-&gt;<a href="https://www.cnblogs.com/java1024/p/8757952.html" target="_blank">这里</a></p>
<ul>
  <li>这里是整理好的面试题，至少都过一遍:
    <ol>
      <li><a href="https://blog.csdn.net/qq_41701956/article/details/86686492">2019年最新java面试题及答案整理上</a></li>
      <li><a href="https://blog.csdn.net/qq_41701956/article/details/86699263">2019年最新java面试题及答案整理下</a></li>
    </ol>
  </li>
</ul>

<h3 id="spring框架">Spring框架</h3>
<ul>
  <li>Spring是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许你选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架</li>
</ul>

<p><a href="https://www.ibm.com/developerworks/cn/java/wa-spring1/index.html">Spring框架</a></p>

<p><img src="assets/post_pics/spring_framework.png" /></p>
<ul>
  <li>以上是spring框架的七个模块，这七个模块分别都可以单独使用，但同时又都可以结合起来使用
    <ul>
      <li>Spring Core：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
      <li>Spring上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
      <li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
      <li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
      <li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
      <li>Spring Web：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
      <li>Spring MVC：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
    </ul>
  </li>
  <li>说实话第一遍看什么都没看懂</li>
</ul>

<h4 id="javabean">JavaBean</h4>
<ul>
  <li>
    <p>看了很久也没看出JavaBean到底是什么，直到看到一个回答：</p>

    <p>JavaBean只是一个标准，这个标准下规定了：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 所有属性私有，所有属性要用getter/setter去设置/取值
  - 公共的无参数构造函数: &lt;code&gt;class()&lt;/code&gt;
  - 实现&lt;code&gt;Serializable&lt;/code&gt;   如果一个类遵循标准的话，那他就是JavaBean
</code></pre></div>    </div>
  </li>
  <li>
    <p>关于JavaBean和Spring：Java于1996年通统一的规范可以设置对象的值（JavaBean），这样子可以保证程序有个恒久的方法，并且向后兼容性。但是在实际的企业开发中，需要实现事务，安全，分布式：JavaBean就不好用了，于是sun就在JavaBean上面堆功能，就把JavaBean变成了EJB。EJB功能强大了，但是也更繁杂了，玉树出现了DI（依赖注入）和AOP（面向切面）技术，通过简单的JavaBean也可以完成EJB的事情，这里的JavaBean简化为POJO，再然后Spring就诞生了</p>
  </li>
</ul>

<h4 id="diioc">DI、IOC</h4>
<ul>
  <li>IOC = Inversion of Control</li>
  <li>比如传统的，如果一个对象是依赖于另一个对象的，那么我们是直接在对象内部实例化对象，手动的。而IOC是有一个专门的容器去创建这些对象，也就是有IOC容器来控制对象的创建；<strong>IOC容器控制了对象，主要控制了外部资源获取</strong></li>
  <li>
    <p>传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入注释对象，有容器帮我们查找及注入注释对象，对象只是被动的接受依赖对象</p>
  </li>
  <li>
    <p>传统的程序设计</p>

    <p><img src="assets/post_pics/v2-468af44ef31c1e4b6a27985afb8cb8c9_1440w.jpg" /></p>
  </li>
  <li>
    <p>加入了IOC的程序设计</p>

    <p><img src="assets/post_pics/v2-b3d253afdaf44b0179f93701eb5efc8e_1440w.jpg" /></p>
  </li>
  <li>
    <p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
  </li>
  <li>
    <p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
  </li>
  <li>
    <p>DI和IoC的关系：IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
  </li>
  <li>在典型的IOC场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时候调用方法。下表列出了IOC的一个实现模式：
    <ul>
      <li>类型一：服务需要实现专门的接口，通过接口，由对象提供这些服务，可以从对象查询依赖性(例如需要附加服务)</li>
      <li>类型二：通过JavaBean的属性分配依赖性</li>
      <li>类型三：依赖性以构造函数的形式提供，不以JavaBean属性的形式公开</li>
    </ul>
  </li>
</ul>

<h4 id="aopaspected-oriented-programming">AOP(Aspected-Oriented Programming)</h4>
<ul>
  <li>AOP(面向方面的编程）：<a href="https://www.jianshu.com/p/007bd6e1ba1b">AOP精彩解释</a>
    <ul>
      <li>AOP(Aspect-Oriented Programming)：是面向对象的补充和完善。面向对象里面有封装，多态和继承来建立一种对象层次结构。但是当我们需要为分散的对象引入公共行为时，OOP显得非常无力。也即是说，封装，多态和继承可以完美的定义对象从上到下的关系，但不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为<strong>横切（cross-cutting）代码</strong>，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
    </ul>
  </li>
  <li>AOP技术，利用一种被称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为<strong>切面（Aspect）</strong>。</li>
  <li>切面（Aspect）：将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
  <li>如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</li>
  <li>利用AOP技术，软件系统被分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的特点是：他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
  <li>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用拦截方法的方式，对该方法进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码。</li>
  <li>除了刚刚讲到的切面，还有很多相关的术语，包括：</li>
  <li>连接点（Join Point）：连接点是在应用程序执行过程中能够插入切面的一个点。这个点可以是类的某个方法调用前，调用后，方法抛出异常后等。切面代码可以利用这些点插入到应用的正常交流中，并添加行为</li>
  <li>通知（Advice）：在特定的连接点，AOP框架执行的动作</li>
  <li>切点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP 通过切点定位到特定的连接点。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。每个类都拥有多个连接点，例如 ArithmethicCalculator类的所有方法实际上都是连接点。</li>
  <li>
    <p>引入（Introduction）：添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
  </li>
  <li>目标对象（Target Object）：包含连接点的对象。也被称作被通知或被代理对象。</li>
  <li>织入（Weaving）：织入描述的是把切面应用到目标对象来创建新的代理对象的过程。 Spring AOP 的切面是在运行时被织入，原理是使用了动态代理技术。Spring支持两种方式生成代理对象：JDK动态代理和CGLib，默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</li>
</ul>



</article>

<div class="page-navigation code">
	
    <a class="next" href="http://localhost:4000/java-on-call-6" title="NEXT: Java On Call 6">&lt;&lt;</a>
		<span> &middot; </span>
  
		<a class="home" href="http://localhost:4000/" title="Back to Index">Index</a>
  
		<span> &middot; </span>
    <a class="prev" href="http://localhost:4000/java-on-call-4" title="PREV: Java On Call 4">&gt;&gt;</a>
  
</div>

<!-- Link Gitalk 的支持文件  -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<script type="text/javascript" src="/assets/js/md5.min.js"></script>
<div id="gitalk-container"></div>     
<script type="text/javascript">
    var gitalk = new Gitalk({
    // gitalk的主要参数
        clientID: 'f075f01270dae871aa15',
        clientSecret: '5a97f06edaad9527cb4a92d6d1ee12a86ec73057',
        repo: 'michaeltaoma.github.io',
        owner: 'michaeltaoma',
        admin: ['michaeltaoma'],
        id: md5(location.pathname),
        
    });
    gitalk.render('gitalk-container');
</script> 
<!-- Gitalk end -->


		</div>

		<div class="footer">
  <span class="block">&copy; 2020 Tao Ma</span>
  <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span>
</div>


	</body>

</html>
