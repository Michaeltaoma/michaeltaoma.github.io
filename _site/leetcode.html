<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Leetcode · Tao Ma</title>


<meta name="description" content="Daily">

<link rel="icon" href="http://localhost:4000/assets/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png">
<link rel="stylesheet" href="http://localhost:4000/assets/core.css">
<link rel="canonical" href="http://localhost:4000/leetcode">
<link rel="alternate" type="application/atom+xml" title="Tao Ma" href="http://localhost:4000/feed.xml" />


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


	</head>

	<body>

		<!--<div style="background-image: url('https://source.unsplash.com/random/360x175');">-->
<!--<div style="background-color: #7BA7AB">-->
<style>

.d-flex {
	position: relative;
	/*background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);*/
	/*background: linear-gradient(-45deg, #134e5e, #71b280);*/
	/*background: linear-gradient(54deg, #260032, #D8186E);*/
	background-size: 400% 400%;
	animation: gradient 10s ease infinite;
	height: 160px;
	width: 100%;
	border-radius: 10px;
}
	input{
		border: 1px solid #ccc;
		width: 30%;
		border-radius: 3px;
		padding: 7px 0px 7px 5px;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075);
		-webkit-transition: border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;
		-o-transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s;
		transition: border-color ease-in-out .15s,box-shadow ease-in-out .15s
            }
	input:focus{
		border-color: #66afe9;
		outline: 0;
		-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);
		box-shadow: inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)
	}
	#search-container ul {
		list-style: none;
		}
	#search-container ul li::before {
	  content: "";
	  background-image: url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/3/fb-heart.gif);
	  background-size: contain;
	  display: inline-block;
	  width: 1em;
	  height: 1em;
	  position: relative;
	  top: 0.1rem;
	  margin-right: 0.2rem;
	}

	@keyframes gradient {
	0% {
		background-position: 0% 50%;
	}
	50% {
		background-position: 100% 50%;
	}
	100% {
		background-position: 0% 50%;
	}
}
</style>


<div class="d-flex ">
	<div class="logo">

		

		<a href="http://localhost:4000/">
<!--			<img src="https://source.unsplash.com/random/460x460" alt="" class="logo-avatar">-->
			<!-- <img src="assets/post_pics/head_icon.jpeg" alt="" class="logo-avatar"> -->
			<img src="assets/post_pics/agB31P6_700bwp.jpg" alt="" class="logo-avatar">

		</a>
		<span class="logo-prompt code">Main</span>
	</div>
<br />

</div>

<br />

<section>
	And hello to u too:) Click the icon above for more detail

	<br />
	<br />

	<div id="search-container" >
		<input type="text" id="search-input" placeholder="search">
		<ul id="results-container"></ul>
	</div>


<!-- Script pointing to search-script.js -->
	<script src="assets/js/search-script.js" type="text/javascript"></script>

<!-- Configuration -->
	<script>
	SimpleJekyllSearch({
  		searchInput: document.getElementById('search-input'),
  		resultsContainer: document.getElementById('results-container'),
  		json: '/search.json'
	})
	</script>

</section>




		<div id="content">
			<article>

	<div class="center">
		<h1 class="title">Leetcode</h1>
		<time class="code">June 6, 2023</time>
	</div>

	<div class="divider"></div>

	<h2 id="daily">Daily</h2>

<h3 id="2021-08-20-valid-sudoku">2021-08-20: Valid Sudoku</h3>

<ul>
  <li>
    <p>都是通过把各行、各列、各个小方块，分别各个放在一个set中，如果有重复的，那么就return false就好了，还有一种思考，是分别构建三个二维数组：<code>char\[9\]\[9\]</code>来存放boolean value。In this case, each 2d array stores the placement situation for row, column and cube(the 3*3 matrix)。row: char[0][0] denotes position 0 at the first row, if this is true, that means there is already a one on that position.</p>
  </li>
  <li>
    <p>It’s difficult to partition the original index to the correct cube position. That is to say, we have nature index to denote which row/column the number belongs to, but we need to manipulate the indexes a little bit to understand how the row, col mapped to the correct cube. So we can calculate the cube index like this: <code>cubeIndex = (row/3)*3 + col/3</code>. The first row/3 that:</p>

    <table>
      <tbody>
        <tr>
          <td>we need to put the nine box here:  _ _ _</td>
          <td>_ _ _</td>
          <td>_ _ _，row/3 tells you which ‘column’(splited by “</td>
          <td>”), however, it only gives an idea of which column to go to if the index of  _ _ _</td>
          <td>_ _ _</td>
          <td>_ _ _ really always starts with 0, 1, 2。So we need to multiply 3 to get the starting position. And then, we add up the column number, in this case, it denotes the offset from the original start position.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Another way is to use [bigRow, bigColumn] to denote the box</p>

    <p><img src="/Users/michaelma/Desktop/Workspace/Screenshots/Snipaste_2021-08-21_18-41-55.png" alt="Snipaste_2021-08-21_18-41-55" style="zoom:50%;" /></p>

    <p>This way we use two index to locate the box</p>
  </li>
  <li>
    <p>To flip a box, just iterate through all the box(little) and set row, col = col, row</p>
  </li>
</ul>

<ol>
  <li>
    <p>initialize</p>

    <p><code>Object name = new Object();</code></p>
  </li>
  <li>
    <p>initialize multiple variables</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Boolean</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>for</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="nl">a:</span> <span class="nc">Object</span><span class="o">[]){</span>
  <span class="c1">//</span>
<span class="o">}</span>
   
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>boolean operator</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//&amp;&amp; and || only evaluate left side(Logical and, logical or)</span>
<span class="c1">//&amp; and | evaluate both sides(bitwise and, or)</span>
<span class="c1">//^ -&gt; XOR,is only true when both operands are of the same value</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>char comparison</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'a'</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="sc">'b'</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'1'</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">d</span> <span class="o">=</span> <span class="sc">'2'</span><span class="o">;</span>
<span class="c1">//just use == to compare, this is a primitive type</span>
<span class="kt">int</span> <span class="n">caseC</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">c</span><span class="o">;</span>
<span class="c1">//That would give you caseC=49 because when cast char to int, the int value equals to the ascii code value for the char.</span>
   
<span class="c1">//char a + char b = ascii value of a + ascii value of b, and then search for the character that has the sum of ascii value</span>
   
<span class="c1">//char a(with number) + int b: 会直接把a囊括的数字'1'变成1，然后和b的数字相加 </span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>java main</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>java <code>1/3</code></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">;</span>
<span class="c1">// a/b produce真实的除法，带有小数点精度的除法，返还一个double</span>
<span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">;</span><span class="n">n</span>
<span class="c1">// c/d 返还int，他只会返还c除以d的整数部分，不返还余数，python中的//则是floor division</span>
<span class="c1">// java的/和python的//是不一样的,当结果是正数的时候表现是一样的</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>comments in java</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//single line</span>
<span class="cm">/* Multiple
Line*/</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="2021-08-21-number-of-ways-to-arrive-at-destination">2021-08-21: Number of ways to arrive at destination</h3>

<ul>
  <li>
    <p>Dijkstra’s shortest path algorithm：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visted = []
unvisted = []
# shortest_path_from_src: {k:v}, k denotes that the shortest path from src to k, v denotes how long this path is
shortest_path_from_src = dict()
# previous_visted: {k:v}, k denotes that the shortest path from src to k, v denotest that this shortest path previously(before visting k) visted v
previous_visted = dict()
# Set up
visted.append(src)
unvisted.remove(src)
shortest_path_from_src[src] = 0
previous_visted[src] = src
for node in all_node:
  shortest_path_from_src[node] = inf
  
while unvisted.is_not_empty():
  smallest_unvisted = find out the unvisted vertex with smallest shortest_path_from_src value
  for the smallest_unvisted:
  	examin the neighbors(unvisted) of the smallest_unvisted
  	add up the distance shortest_path_from_src[smallest_unvisted_neighbours]
  	which is shortest_path_from_src[smallest_unvisted_neighbours] = shortest_path_from_src[smallest_unvisted] + dist(smallest_un, neighbours)
  	see if any update to make(if shortest_path_from_src[smallest_unvisted_neighbours] is less than its previous value)
  	add the current smallest_unvisted to the visted_vertex
</code></pre></div>    </div>
  </li>
  <li>
    <p>minheap</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">roads</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">roads</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">time</span><span class="p">])</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">time</span><span class="p">])</span>
  
        <span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="p">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">ways</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">src</span><span class="p">)]</span>  <span class="c1"># dist, src
</span>            <span class="n">dist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ways</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">minHeap</span><span class="p">:</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span> <span class="k">continue</span>  <span class="c1"># Skip if `d` is not updated to latest version!
</span>                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span><span class="p">:</span>
                        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span>
                        <span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ways</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                        <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span><span class="p">:</span>
                        <span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">ways</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1_000_000_007</span>
            <span class="k">return</span> <span class="n">ways</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  
        <span class="k">return</span> <span class="n">dijkstra</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>    </div>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[A]--1-[C]
 |  \     \	
 1   4	   -2--[E]
 |    \         1
[B]-1--[D]------|
  
set_visted = {A, B, D, C}
  
set_not_visted = {E}	
  
dist: A:0, B:1, C:1, D:2, E:3
  
dp: A:1, B:1, C:1, D:1, E:2
  
A:
  
for each of {B, C, D} as x:
	curr_shortest = dist[B]
	if dist[A] + long(A, x) &lt; curr_shortest:
		dist[x] = dist[A] + long(A, x)
		dp[x] = dp[A]
	else:
		pass
  
B:
  
for each of {D}:
	curr_shortest = dist[D]
	pass_by_B = dist[B] + long(B, D) = 2
	# better
	dist[D] = 2
	dp[D] = dp[B]
  
C:
for each of {E}:
	curr_shortest = dist[E]
	pass_by_C = dist[C] + long(C, E) = 3
	# better
	dist[E] = 3
	dp[E] = dp[C]
  
D:
for each of {E}:
	curr_shortest = dist[D]
	pass_by_D = dist[D] + long(D, E) = 3
	# same good
	dist[E] = 3
	dp[E] = dp[D] + dp[E] = 2
E:
	all visted	
  
一个简单的迪杰斯特拉的一个walkthrough，在这里，最关键的是要知道我们遍历结束的条件不是访问到最终的node就完了，而是要把set_not_visted的node全部vist完才算是搞定
而迪杰斯特拉搞定了，那我们如何知道从起点到终点总共有多少条最短的路径呢？访问到一个node的时候，会examine他的neighbor，如果说起点经过我到neighbor的用时比起点不知道怎么的到
neighbor的用时要短，那么显然，经过我是最短的，而到neighbor的最短路径的数量，和到我的最短路径的数量一样。那么如果是说起点经过我到neighbor的用时比起点不知道怎么的到
neighbor的用时是一样的话，那么说明总共有（到我的最短路径+不知道怎地去到neighbor的最短路径）那么多的最短路径到neighbor
</code></pre></div>    </div>
  </li>
  <li>
    <p>why have to  <code>if dist[u] &lt; d: continue</code></p>
  </li>
  <li>
    <p>还用到了dynamic programming</p>

    <ul>
      <li>
        <p>dp用在了在记录到某点的最短路径的数量上，他的逻辑存在于迪杰斯特拉算法的判断“从某点来是否比原来的更短”的这个，以下这个逻辑里</p>

        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span><span class="p">:</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span>
  <span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ways</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
  <span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
<span class="k">elif</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">time</span><span class="p">:</span>
	<span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ways</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">ways</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1_000_000_007</span>
</code></pre></div>        </div>

        <p>他的逻辑是如果经过u来的v的时间比经过别的地方来到v的时间更短，那么到v点的最短路径的数量必然也等于到u点的最短路径数量。同样，如果经过u来v的时间和经过别的点来v的时间一样短，那么到v点的最短路径数量应该等于原最短路径数量加上经过u到v的最短路径数量</p>
      </li>
    </ul>
  </li>
  <li>
    <p>java stack，stack is empty</p>

    <ul>
      <li>isEmpty return true if stack is empty(每个collection都有)</li>
      <li>empty return true iff the stack is empty(只在stack实现)</li>
      <li>本质上没有区别</li>
    </ul>
  </li>
  <li>
    <p>initialize collection, specifying item’s type：<code>Stack<Integer> a = new Stack&lt;&gt;();&lt;/code&gt;</Integer></code></p>
  </li>
  <li>
    <p>Initialize double with number: <code>double a = 0d;</code></p>
  </li>
  <li>
    <p>priority queue:</p>

    <ul>
      <li><code>PriorityQueue<Integer> pq = new PriorityQueue&lt;&gt;(); &lt;/code&gt;</Integer></code></li>
      <li>head存的是最小的东西，而“大小”的概念可以在initialize的时候pass一个comparator到这个priority queue的对象里</li>
      <li>add/offer都是增加，当没有capacity的时候
        <ul>
          <li>add会抛出异常</li>
          <li>offer会返还false</li>
        </ul>
      </li>
      <li>poll就像pop，把头变回来</li>
    </ul>
  </li>
  <li>
    <p>Array .fill：Arrays.fill(array, val)</p>
  </li>
  <li>
    <p>为什么要mod？</p>

    <ul>
      <li>modulo 10**9 + 7</li>
      <li>因为有些数字相乘的操作之后，会溢出存储的格式，那么使用modulo可以保证这个数字一直在存储范围内</li>
    </ul>
  </li>
  <li>
    <p>坑点：不能用int去存距离</p>
  </li>
</ul>

<h3 id="2021-08-23-lru-cache">2021-08-23: LRU Cache</h3>

<ul>
  <li>LRU
    <ul>
      <li>Didn’t understand lru cache quite well. lru cache is short for “least recently used cache”. Basically, I thought every “accesse” and “change of value” of certain key-value pair weights differently. However, for lru, each “access” and “change of value” can be regarded as a “visit” to that specific kv pair hence the kv pair should be immediately moved to the tail of the priority queue.</li>
    </ul>
  </li>
  <li>
    <p>Hashtable</p>

    <ul>
      <li><code>Hashtable\&lt;Object, Object\&gt; hashtable = new Hashtable\&lt;\&gt;();</code></li>
      <li>containsKey; get; put; isEmpty; size</li>
    </ul>
  </li>
  <li>
    <p>LinkedList</p>

    <ul>
      <li><code>LinkedList\&lt;Object\&gt; linkedList = new LinkedList&lt;&gt;();</code></li>
      <li>增加：
        <ul>
          <li>add: 没有除元素外参数的add，直接加在linkedlist的最后面</li>
          <li>offer：没有除元素外参数的offer，直接加在linkedlist的最后面</li>
          <li>push：没有除元素外参数的push，直接把元素加在linkedlist的最前面</li>
        </ul>
      </li>
      <li>减少：
        <ul>
          <li>remove：直接得到并去除linkedlist的最前面的，没有的话会throw exception</li>
          <li>pop；直接得到并除去linkedlist最前面，没有的话会throw exception</li>
          <li>poll：直接得到去除最前面的元素，没有的话会返还null</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>priority queue with comparator</p>

    <ul>
      <li>
        <p>comprator：</p>

        <pre><code class="language-Java">class NodeComparator implements Comparator&lt;Node&gt;{
  //只用实现compare
  public int compare(Node n1, Node n2){
    //return -1 if n2 is larger
    //return 1 if n1 is larger
    //return 0 if equals
  }
}
</code></pre>
      </li>
    </ul>
  </li>
  <li>
    <p>.equals</p>

    <pre><code class="language-Java">@Override
public boolean equals(Object object){
  if (object instanceOf Node){
    Node nodeObj = (Node)object;
  }
  return false;
}
</code></pre>
  </li>
  <li>
    <p>linkedHashMap</p>

    <ul>
      <li>design specifically for lru cache…</li>
      <li>maintain the insertion order or the access order of kv pair, use access order for lru cache</li>
      <li>only need to override one method: removeEldestEntry，this method tells the object when to remove the eldest entry, in our case, we need to remove the eldest entry when our cache is full: this.size() &gt; capacity</li>
      <li>use getOrDefault to specify the return value when mis hit, else it will return null using get</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.LinkedHashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
  
<span class="cm">/**
 * Created by fhqplzj on 16-7-11 at 下午5:41.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="kd">extends</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
  
    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="2021-08-25-1936-add-minimum-number-of-rungs">2021-08-25 1936: Add Minimum Number of Rungs</h3>

<ul>
  <li>贪心</li>
  <li>向上取整</li>
  <li>向下取整
    <ul>
      <li>就是2.3-&gt; 2，3.3-&gt;3</li>
      <li>The reason we should use floor division to approach this question is because we want to know how many stairs we need to insert in between. If the division returns 2.3，that  means we need to take 2.3 steps to get there, however, in the last 0.7 steps, we can just step to the new stair immediately, we don’t need to insert new stairs. For example, the current step size is 2, and we need to go to stair at height 10, we are now at stair at height 5. In this case, (10 - 5)/2 gives us 2.5, but we only need 2 stairs to get to 10. So we take a floor division on (target - current)/dist. The reason for (target - current - 1)//dist is because we want to prevent situation when (target - current) is divisible by dist, in case, floor division will return something not optimal(target: 13, current: 5, dist: 2, we get 4 if we dont minus one), so we minus one.</li>
    </ul>
  </li>
  <li>concat 2 arrays</li>
</ul>

<h3 id="2021-09-30-add-two-numbers">2021-09-30: Add two numbers</h3>

<ul>
  <li>思考过程：一开始想尝试的方法是，先把两个由linked list代表的数字转换成普通的int存成primitive type，然后用primitive type相加，再把结果直接转换成linked list代表的数字
    <ul>
      <li>问题1:integer overflow，这里能够允许最多100个nodes，并且每个node最多可以代表数字9，所以最多能存$\approx 9*10^{100}$ ,但是java的int最多也只能存4 bytes，也就是$2^{32}$，所以把linked list链接的数字强行cast到int是有很巨大的风险的</li>
      <li>问题2:在已知integer的情况下，很难只通过这个integer就把这个数字的十位数，百位数给分离开来 -&gt; 可以用什么string split，但现在发现用到这种的基本都是裂开的</li>
    </ul>
  </li>
  <li>
    <p>答案：把linked list每一步相加的过程都当作在计算整数加法，列竖式的感觉。自己先在纸上演示一遍，然后发现carry是怎样确定的</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
  <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">addTwoNumbers</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">l1</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">l2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ListNode</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="c1">//必须要整清楚ptr和本来的头，如果不小心没有记录本来的头的话，linked list就丢了</span>
    <span class="nc">ListNode</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">,</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">l1Val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">l2Val</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">ptr1</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ptr2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
      <span class="n">l1Val</span> <span class="o">=</span> <span class="o">(</span><span class="n">ptr1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)?</span><span class="n">ptr1</span><span class="o">.</span><span class="na">val</span><span class="o">:</span><span class="mi">0</span><span class="o">;</span>
      <span class="n">l2Val</span> <span class="o">=</span> <span class="o">(</span><span class="n">ptr2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)?</span><span class="n">ptr2</span><span class="o">.</span><span class="na">val</span><span class="o">:</span><span class="mi">0</span><span class="o">;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">ptr1</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr1</span><span class="o">.</span><span class="na">next</span><span class="o">;}</span>
      <span class="k">if</span><span class="o">(</span><span class="n">ptr2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span><span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr2</span><span class="o">.</span><span class="na">next</span><span class="o">;}</span>
      <span class="n">sum</span> <span class="o">=</span> <span class="n">l1Val</span> <span class="o">+</span> <span class="n">l2Val</span> <span class="o">+</span> <span class="n">carry</span><span class="o">;</span>
      <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span><span class="o">/</span><span class="mi">10</span><span class="o">;</span>
      <span class="nc">LinkedNode</span> <span class="n">currNext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">sum</span><span class="o">%</span><span class="mi">10</span><span class="o">);</span>
      <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">currNext</span><span class="o">;</span>
      <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">carry</span><span class="o">);}</span>
    <span class="k">return</span> <span class="n">dummyHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>比较要注意的点是要分清真正的ptr和head在哪</li>
</ul>

<h3 id="sorting">Sorting</h3>

<h3 id="2021-10-14-49-group-anagrams">2021-10-14: 49. Group Anagrams</h3>

<p>description:</p>

<p>Given an array of strings <code class="language-plaintext highlighter-rouge">strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>

<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>

<p>一开始的思路：维护一个set -&gt; list的数据结构，其中，set代表的是字母的出现，而他对应的list则是由这个字母的出现组成的单词在strs中的index。比如set(e, a, t):[0, 1, 2]就代表着，由e，a，t组成的单词(eat, eta, tea, tae)。但这东西在一开始就没想清楚，因为set会把重复的elem给prune掉，这样子的话，eat和eaat也会被判定为是符合要求的anagram，但其实是错误的。</p>

<p>修改了的思路：只要是anagrams，那么他们的sort好的string一定是一样的，所以：利用string -&gt; list，string就是sort好的string，其他的东西都和原来的想法保持一致</p>

<ul>
  <li>用Arrays这个package里的sort-&gt;<code class="language-plaintext highlighter-rouge">Arrays.sort()</code>可以在O(nlogn)中sort array的值</li>
  <li>str.toCharArray() -&gt; string -&gt; char array</li>
</ul>

<h3 id="2021-10-14-56-merge-intervals">2021-10-14: 56. Merge Intervals</h3>

<p>description:</p>

<p>Given an array of <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>

<p>一开始的思路：目前的2d array中存着的是interval，先根据各个interval的起点从小到大sort这个interval array，然后扫过一遍interval，有两个ptr，一个ptr指向目前达不到的interval（和之前overlap的东西完全断开），一个ptr指向“可能可以达到的interval”。在每一步，我们看现在的和之前overlap的interval完全断开的interval能不能和ptr指向的interval overlap，如果可以，就合并，然后把这合并了之后的作为第一个ptr指向的东西，然后持续increment另一个ptr。对于[a, b], [c, d]，判断能否合并的规则基于b和c的关系，如果b大于等于c，那么是可以合并的，合并之后的interval[a, x]，x要定位的是b和d中更大的那个: <a href="#2021-10-14: 56. Merge Intervals Code">代码</a></p>

<p>更好的思路：</p>

<h3 id="2021-10-15-1818-minimum-absolute-sum-difference">2021-10-15: 1818. Minimum Absolute Sum Difference</h3>

<p>You are given two positive integer arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code>, both of length <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>The <strong>absolute sum difference</strong> of arrays <code class="language-plaintext highlighter-rouge">nums1</code> and <code class="language-plaintext highlighter-rouge">nums2</code> is defined as the <strong>sum</strong> of <code class="language-plaintext highlighter-rouge">|nums1[i] - nums2[i]|</code> for each <code class="language-plaintext highlighter-rouge">0 &lt;= i &lt; n</code> (<strong>0-indexed</strong>).</p>

<p>You can replace <strong>at most one</strong> element of <code class="language-plaintext highlighter-rouge">nums1</code> with <strong>any</strong> other element in <code class="language-plaintext highlighter-rouge">nums1</code> to <strong>minimize</strong> the absolute sum difference.</p>

<p>Return the <em>minimum absolute sum difference <strong>after</strong> replacing at most one element in the array <code class="language-plaintext highlighter-rouge">nums1</code>.</em> Since the answer may be large, return it <strong>modulo</strong> <code class="language-plaintext highlighter-rouge">109 + 7</code>.</p>

<p><code class="language-plaintext highlighter-rouge">|x|</code> is defined as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">x</code> if <code class="language-plaintext highlighter-rouge">x &gt;= 0</code>, or</li>
  <li><code class="language-plaintext highlighter-rouge">-x</code> if <code class="language-plaintext highlighter-rouge">x &lt; 0</code>.</li>
</ul>

<p>一开始的思路：暴力。把nums1每个位置的都替换成nums1别的值，然后把abs sum diff都分别计算，然后最后来个排序。对于长度为n的总共需要$n\times(n-1)$.<a href="#2021-10-14: 1818. Minimum Absolute Sum Difference Code">代码</a></p>

<h3 id="2021-10-15-2007-find-original-array-from-doubled-array">2021-10-15: 2007. Find Original Array From Doubled Array</h3>

<p>An integer array <code class="language-plaintext highlighter-rouge">original</code> is transformed into a <strong>doubled</strong> array <code class="language-plaintext highlighter-rouge">changed</code> by appending <strong>twice the value</strong> of every element in <code class="language-plaintext highlighter-rouge">original</code>, and then randomly <strong>shuffling</strong> the resulting array.</p>

<p>Given an array <code class="language-plaintext highlighter-rouge">changed</code>, return <code class="language-plaintext highlighter-rouge">original</code> <em>if</em> <code class="language-plaintext highlighter-rouge">changed</code> <em>is a <strong>doubled</strong> array. If</em> <code class="language-plaintext highlighter-rouge">changed</code> <em>is not a <strong>doubled</strong> array, return an empty array. The elements in</em> <code class="language-plaintext highlighter-rouge">original</code> <em>may be returned in <strong>any</strong> order</em>.</p>

<p>一开始的思路：无</p>

<h3 id="2021-10-16-1235-maximum-profit-in-job-scheduling">2021-10-16: 1235. Maximum Profit in Job Scheduling</h3>

<p>We have <code class="language-plaintext highlighter-rouge">n</code> jobs, where every job is scheduled to be done from <code class="language-plaintext highlighter-rouge">startTime[i]</code> to <code class="language-plaintext highlighter-rouge">endTime[i]</code>, obtaining a profit of <code class="language-plaintext highlighter-rouge">profit[i]</code>.</p>

<p>You’re given the <code class="language-plaintext highlighter-rouge">startTime</code>, <code class="language-plaintext highlighter-rouge">endTime</code> and <code class="language-plaintext highlighter-rouge">profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.</p>

<p>If you choose a job that ends at time <code class="language-plaintext highlighter-rouge">X</code> you will be able to start another job that starts at time <code class="language-plaintext highlighter-rouge">X</code>.</p>

<p>一开始的思路：无</p>

<p>改进的思路：对于每个工作来说，都只有两种可能：1. 这个工作在整个maximum的path里 2. 这个工作不在整个maximum的path里。那么也就是说，现在可以利用这两个想法去完成算法：从abstract view来看，我们先按照工作开始时间给这一堆工作排序，紧接着，我们从最早开始时间开始遍历这些工作：当遍历到工作1，我们比较工作1的两个可能：当工作1属于maximum path和当他不在的时候，也就是像递归一样：<code class="language-plaintext highlighter-rouge">compare(currentValue + findMax(nextIndex), findMax(nextPosition))</code>，nextPosition找的直接是比目前examine的job更晚开始的job，但是nextIndex指的是，如果选了这个工作，我们接下来该这么选，这个用的是binary search去定位</p>

<h3 id="2021-10-16-253-meeting-rooms-ii">2021-10-16: 253. Meeting Rooms II</h3>

<p>Given an array of meeting time intervals <code class="language-plaintext highlighter-rouge">intervals</code> where <code class="language-plaintext highlighter-rouge">intervals[i] = [starti, endi]</code>, return <em>the minimum number of conference rooms required</em>.</p>

<p>一开始的思路：无</p>

<p>改进的思路：模拟一下寻找空的房间的过程：对于一个meeting，尽可能的找到结束时间最早的房间。可以直接维护一个priority queue，其中每个node都是一个房间，然后queue的值就是这个房间的会议的结束时间，所以queue的头表示的就是目前最快能够结束会议的房间，然后遍历工作，如果queue的头（目前最快能够结束会议的房间）的时间要小于工作的时间，那么我们就更新queue头变成目前工作的工作时间，如果大于，那么就在queue里多加一个房间 <a href="#2021-10-16: 253. Meeting Rooms II Code">代码</a></p>

<h3 id="2021-10-17-75-sort-colors">2021-10-17: 75. Sort Colors</h3>

<p>Given an array <code class="language-plaintext highlighter-rouge">nums</code> with <code class="language-plaintext highlighter-rouge">n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>

<p>We will use the integers <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, and <code class="language-plaintext highlighter-rouge">2</code> to represent the color red, white, and blue, respectively.</p>

<p>You must solve this problem without using the library’s sort function.</p>

<p>一开始的思路：很简单，就是个简单的sort，要注意的是我们要修改的是array本身的东西，pass by reference，但是好像是incorrect？？？<a href="#2021-10-17: 75. Sort Colors Code">代码</a></p>

<p>更好的思路：</p>

<h3 id="2021-10-17-147-insertion-sort-list">2021-10-17: 147. Insertion Sort List</h3>

<p>Given the <code class="language-plaintext highlighter-rouge">head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list’s head</em>.</p>

<p>The steps of the <strong>insertion sort</strong> algorithm:</p>

<ol>
  <li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>
  <li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>
  <li>It repeats until no input elements remain.</li>
</ol>

<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>

<p>一开始的思路：</p>

<p>改进的思路：<a href="#2021-10-17: 147. Insertion Sort List Code">代码</a></p>

<h3 id="2021-10-18-215-kth-largest-element-in-an-array">2021-10-18: 215. Kth Largest Element in an Array</h3>

<p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">kth</code> <em>largest element in the array</em>.</p>

<p>Note that it is the <code class="language-plaintext highlighter-rouge">kth</code> largest element in the sorted order, not the <code class="language-plaintext highlighter-rouge">kth</code> distinct element.</p>

<p>一开始的思路：很简单，写个排序就好了 <a href="#2021-10-18: 215. Kth Largest Element in an Array Code">代码</a></p>

<p>更好的思路：</p>

<h3 id="2021-10-18-973-k-closest-points-to-origin">2021-10-18: 973. K Closest Points to Origin</h3>

<p>Given an array of <code class="language-plaintext highlighter-rouge">points</code> where <code class="language-plaintext highlighter-rouge">points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code class="language-plaintext highlighter-rouge">k</code>, return the <code class="language-plaintext highlighter-rouge">k</code> closest points to the origin <code class="language-plaintext highlighter-rouge">(0, 0)</code>.</p>

<p>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code class="language-plaintext highlighter-rouge">√(x1 - x2)2 + (y1 - y2)2</code>).</p>

<p>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</p>

<p>一开始的思路：先遍历一遍，把所有坐标的距离都找出来，写个归并排序排序，很简单 <a href="#2021-10-18: 973. K Closest Points to Origin Code">代码</a></p>

<h3 id="2021-10-19-1-two-sum">2021-10-19: 1. Two Sum</h3>

<p>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of <code class="language-plaintext highlighter-rouge">n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code class="language-plaintext highlighter-rouge">[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= a, b, c, d &lt; n</code></li>
  <li><code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">d</code> are <strong>distinct</strong>.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>

<p>You may return the answer in <strong>any order</strong>.</p>

<p>一开始的思路：先把原来的nums给sort好，一定要把原来的index给记录下来。然后利用两个pointer，分别指向sort好的array的头尾两侧（假设此时arr是按照小到大的顺序给sort好的） <a href="#2021-10-19: 1. Two Sum Code">代码</a></p>

<p>更好（不一样）的思路</p>

<h3 id="2021-10-19-15-3sum">2021-10-19: 15. 3sum</h3>

<p>Given an integer array nums, return all the triplets <code class="language-plaintext highlighter-rouge">[nums[i], nums[j], nums[k]]</code> such that <code class="language-plaintext highlighter-rouge">i != j</code>, <code class="language-plaintext highlighter-rouge">i != k</code>, and <code class="language-plaintext highlighter-rouge">j != k</code>, and <code class="language-plaintext highlighter-rouge">nums[i] + nums[j] + nums[k] == 0</code>.</p>

<p>Notice that the solution set must not contain duplicate triplets.</p>

<p>一开始的思路：一样和2sum一样使用双指针，并且尝试把问题规约到2sum的问题。首先要把nums给sort好，然后逐个遍历nums的元素，当遍历到元素nums[i]，我们可以把剩下的arr丢进2sum的算法里面去，希望从剩下的arr寻找target=-nums[i]的结果。但是实际上的操作要比这里讲的要复杂很多：</p>

<ul>
  <li>
    <p>为了提高运行的效率，在sort好了arr之后，不考虑所有nums[i] &gt; 0的情况，因为如果num[i] &gt; 0，算法会进可能的从nums[i+1:]中找到加起来等于负数的解，但明显不可能</p>
  </li>
  <li>为了确保答案的唯一性，我们在遍历nums的时候要确保不要重复运行相同target的2sum，比如如果判断nums[i] == nums[i-1]的话，直接跳过这个遍历</li>
  <li>虽然要保证一个结果：[1,2,3]的唯一性，但是对于相同的nums[i]，并没有假设只有唯一的2sum结果（但是在2sum这一题则这样明确了），所以在找到了一个2sum结果的时候，需要缩小范围了之后继续搜索</li>
  <li>虽然但是，紧接上条，如果出现了对称的list：[0,0,2,2]，2，这样的话即使左右都缩小了一个范围，我们还是会得到duplicate的结果，所以还要判断任意一边：<code class="language-plaintext highlighter-rouge">while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]){left++;}</code>，这里用right来判断也可以</li>
  <li>最后的感想：简单快排真他妈垃圾，连测试都过不了，换成merge之后快了很多<a href="#2021-10-19: 15. 3sum Code">代码</a></li>
</ul>

<p>更好（不一样）的思路：</p>

<h3 id="2021-10-19-18-4sum">2021-10-19: 18. 4sum</h3>

<p>Given an array <code class="language-plaintext highlighter-rouge">nums</code> of <code class="language-plaintext highlighter-rouge">n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code class="language-plaintext highlighter-rouge">[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= a, b, c, d &lt; n</code></li>
  <li><code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">d</code> are <strong>distinct</strong>.</li>
  <li><code class="language-plaintext highlighter-rouge">nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>

<p>You may return the answer in <strong>any order</strong>.</p>

<p>一开始的思路：$n^3$?直接4sum调3sum，3sum调2sum。但是这里在4sum和3sum的调用会有些许的不一样：</p>

<ul>
  <li>在3sum中：我们“为了提高运行的效率，在sort好了arr之后，不考虑所有nums[i] &gt; 0的情况，因为如果num[i] &gt; 0，算法会进可能的从nums[i+1:]中找到加起来等于负数的解，但明显不可能”，更generalize一点，就是“为了提高运行的效率，在sort好了arr之后，不考虑所有nums[i] &gt; target的情况，因为如果num[i] &gt; 0，算法会进可能的从nums[i+1:]中找到加起来等于负数的解，但明显不可能”，这样的筛检手段只针对target&gt;=0适用，因为只要当nums[i] &gt; target，那么target - nums[i]就必定是个负数，而因为nums[i] &gt; target &gt;= 0，且这个数组已经排列好的了，那么我们不可能可以从剩下的arr找到一组加起来小于0的解。但是当target&lt;0的时候，在这里并不适用，因为现在我们要找到的是target，当target &lt; 0 的时候，虽然nums[i] &gt; target，但这没有明确nums[i]和0的关系，他还可以是负的，我们根本无法排除掉这个值之后的arr，例如target是-11，nums[i]是-5，虽然nums[i]确实大于target，但target减去nums[i]得到的是-6，-5后面跟一个-4和-2解就存在了</li>
</ul>

<p>别的基本一样：<a href="#2021-10-19: 18. 4sum Code">Code</a></p>

<p>更好的思路：</p>

<h3 id="2021-10-19-767-reorganize-string">2021-10-19: 767. Reorganize String</h3>

<p>Given a string <code class="language-plaintext highlighter-rouge">s</code>, rearrange the characters of <code class="language-plaintext highlighter-rouge">s</code> so that any two adjacent characters are not the same.</p>

<p>Return <em>any possible rearrangement of</em> <code class="language-plaintext highlighter-rouge">s</code> <em>or return</em> <code class="language-plaintext highlighter-rouge">""</code> <em>if not possible</em>.</p>

<p>一开始的思路：无</p>

<p>更好的思路：利用了hashmap和priority queue。首先，利用hashmap把各个char的出现的次数记录下来：’a’:20说明a总共出现了20次，然后，把每个键值对按照出现次数都存在pq里。然后开始构建我们需要的string：我们每次从pq里取出一个char（目前在pq里排名最高的那个），然后先比对他和目前string的最后一位是不是一样的char，如果是的话，说明违背了题目的规则，我们接下来从pq中再取出一个东西出来（此时的排位第二的char），把它放进去，如果我们发现此时已经没有东西取了，那么直接返还一个空的str。伪代码如下：</p>

<ul>
  <li>构建priority queue，其中存的是char:occurrences这样的键值对，pq中用occur从大到小来排列</li>
  <li>构建res（我们要返还的string）</li>
  <li>while (res.length() &lt; 原来的str的长度)
    <ul>
      <li>如果这是第一个：
        <ul>
          <li>从pq中取出目前最大的char1</li>
          <li>如果char1 == res[-1]
            <ul>
              <li>如果pq此时已经没有额外的键值对，那么说明已经没有char可以解决这个问题了
                <ul>
                  <li>return空str</li>
                </ul>
              </li>
              <li>如果有：
                <ul>
                  <li>从pq中取出目前最大的char2</li>
                  <li>把char2加入res中，decrease char2的value</li>
                  <li>把char1和char2加回pq</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>如果char1 != res[-1]
            <ul>
              <li>把char1加入res中，decrease char1的value</li>
              <li>把char1加回pq（如果还有的话）</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>返还res</li>
</ul>

<p><a href="#2021-10-19: 767. Reorganize String Code">code</a></p>

<h3 id="2021-10-22-1152-analyze-user-website-visit-pattern">2021-10-22: 1152. Analyze User Website Visit Pattern</h3>

<p>You are given two string arrays <code class="language-plaintext highlighter-rouge">username</code> and <code class="language-plaintext highlighter-rouge">website</code> and an integer array <code class="language-plaintext highlighter-rouge">timestamp</code>. All the given arrays are of the same length and the tuple <code class="language-plaintext highlighter-rouge">[username[i], website[i], timestamp[i]]</code> indicates that the user <code class="language-plaintext highlighter-rouge">username[i]</code> visited the website <code class="language-plaintext highlighter-rouge">website[i]</code> at time <code class="language-plaintext highlighter-rouge">timestamp[i]</code>.</p>

<p>A <strong>pattern</strong> is a list of three websites (not necessarily distinct).</p>

<ul>
  <li>For example, <code class="language-plaintext highlighter-rouge">["home", "away", "love"]</code>, <code class="language-plaintext highlighter-rouge">["leetcode", "love", "leetcode"]</code>, and <code class="language-plaintext highlighter-rouge">["luffy", "luffy", "luffy"]</code> are all patterns.</li>
</ul>

<p>The <strong>score</strong> of a <strong>pattern</strong> is the number of users that visited all the websites in the pattern in the same order they appeared in the pattern.</p>

<ul>
  <li>For example, if the pattern is <code class="language-plaintext highlighter-rouge">["home", "away", "love"]</code>, the score is the number of users <code class="language-plaintext highlighter-rouge">x</code> such that <code class="language-plaintext highlighter-rouge">x</code> visited <code class="language-plaintext highlighter-rouge">"home"</code> then visited <code class="language-plaintext highlighter-rouge">"away"</code> and visited <code class="language-plaintext highlighter-rouge">"love"</code> after that.</li>
  <li>Similarly, if the pattern is <code class="language-plaintext highlighter-rouge">["leetcode", "love", "leetcode"]</code>, the score is the number of users <code class="language-plaintext highlighter-rouge">x</code> such that <code class="language-plaintext highlighter-rouge">x</code> visited <code class="language-plaintext highlighter-rouge">"leetcode"</code> then visited <code class="language-plaintext highlighter-rouge">"love"</code> and visited <code class="language-plaintext highlighter-rouge">"leetcode"</code> <strong>one more time</strong> after that.</li>
  <li>Also, if the pattern is <code class="language-plaintext highlighter-rouge">["luffy", "luffy", "luffy"]</code>, the score is the number of users <code class="language-plaintext highlighter-rouge">x</code> such that <code class="language-plaintext highlighter-rouge">x</code> visited <code class="language-plaintext highlighter-rouge">"luffy"</code> three different times at different timestamps.</li>
</ul>

<p>Return <em>the <strong>pattern</strong> with the largest <strong>score</strong></em>. If there is more than one pattern with the same largest score, return the lexicographically smallest such pattern.</p>

<p>一开始的想法：暴力，目的是把所有的pattern出现的次数都统计出来。这里很容易看出我们对于pattern是按照user来统计的，所以先用user找出所有的pattern：根据user，找出user访问过的所有网站，按照timestamp来罗列（这题真的非常恶心，他的timestamp都没有sort好，并且他给出来的例子让你以为他都是sort好的），然后把每个user的所有pattern都找出来，最后再统计次数。虽然想法不算很绕，但是细节比较多，如果要用pq写的话需要自己整comparator：<a href="#2021-10-22: 1152. Analyze User Website Visit Pattern Code">code</a></p>

<h3 id="2021-10-25-621-task-scheduler">2021-10-25 621. Task Scheduler</h3>

<p>Given a characters array <code class="language-plaintext highlighter-rouge">tasks</code>, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.</p>

<p>However, there is a non-negative integer <code class="language-plaintext highlighter-rouge">n</code> that represents the cooldown period between two <strong>same tasks</strong> (the same letter in the array), that is that there must be at least <code class="language-plaintext highlighter-rouge">n</code> units of time between any two same tasks.</p>

<p>Return <em>the least number of units of times that the CPU will take to finish all the given tasks</em>.</p>

<p>一开始的想法：暴力贪心，先用priority queue按照需要schedule的次数存放所有的task，每一次都先找到最需要处理的task（pq第一个）， 尝试在时间里加入这个，遍历之前n个元素，如果n个元素内没有相同的task，就可以加入，一直遍历到没有task为止，大致的算法是，超出时间限制: <a href="#621. Task Scheduler code">code</a></p>

<p>改进的想法：用二元数组遍历记录任务i的信息：（下一次可供调度的时间，还剩下需要调动的次数）。然后遍历二元数组，找到目前时间t下：可供调动，且需要调动次数最多的任务。这其中最巧妙的地方是，我们先找到最早的可供调度的任务之后，直接把时间t加到那个最早的时间（如果t&lt;最早的可供调度的任务的话）。这样做的目的是可以直接把需要idle时的遍历给抹掉！！非常关键！！<a href="#621. Task Scheduler better code">code</a></p>

<h3 id="2021-10-26-692-top-k-frequent-words">2021-10-26: 692. Top K Frequent Words</h3>

<p>Given an array of strings <code class="language-plaintext highlighter-rouge">words</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">k</code> <em>most frequent strings</em>.</p>

<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>

<p>一开始的想法：map：string：occurrences -&gt; pq，在pq中实现comparator（包含lexi order），逐个抽取 <a href="#2021-10-26: 692. Top K Frequent Words code">code</a></p>

<p>更好的想法：</p>

<h3 id="2021-10-27-347-top-k-frequent-elements">2021-10-27: 347. Top K Frequent Elements</h3>

<p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code> and an integer <code class="language-plaintext highlighter-rouge">k</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>

<p>一开始的想法：map：Integer：occurrences -&gt; pq，在pq中实现comparator（改写一下，令pq一开始存的是最大的），逐个抽取<a href="#2021-10-27: 347. Top K Frequent Elements code">code</a></p>

<p>更好的想法：</p>

<h3 id="2021-10-27-1647-minimum-deletions-to-make-character-frequencies-unique">2021-10-27: 1647. Minimum Deletions to Make Character Frequencies Unique</h3>

<p>A string <code class="language-plaintext highlighter-rouge">s</code> is called <strong>good</strong> if there are no two different characters in <code class="language-plaintext highlighter-rouge">s</code> that have the same <strong>frequency</strong>.</p>

<p>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code class="language-plaintext highlighter-rouge">s</code> <em><strong>good</strong>.</em></p>

<p>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code class="language-plaintext highlighter-rouge">"aab"</code>, the <strong>frequency</strong> of <code class="language-plaintext highlighter-rouge">'a'</code> is <code class="language-plaintext highlighter-rouge">2</code>, while the <strong>frequency</strong> of <code class="language-plaintext highlighter-rouge">'b'</code> is <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>一开始的想法：先把String变成char array，然后扫过这个char array。扫的时候把每个字母的frequencies都统计下来，然后加入一个freq set中，当扫到一个字母的freq已经存在freq set中的时候，#deletion++，代表我们需要删掉这个字母的一个，这样遍历下去。需要注意的是对一些edge case的处理 <a href="2021-10-27: 1647. Minimum Deletions to Make Character Frequencies Unique code">code</a></p>

<p>改进的想法：</p>

<h3 id="2021-11-08-912-sort-an-array">2021-11-08: 912. Sort an Array</h3>

<p>Given an array of integers <code class="language-plaintext highlighter-rouge">nums</code>, sort the array in ascending order.</p>

<p>一开始的想法：<a href="2021-11-08: 912. Sort an Array Code">code</a></p>

<p>改进的想法：</p>

<h3 id="dynamic-programming">Dynamic Programming</h3>

<h3 id="2021-11-09-5-longest-palindromic-substring">2021-11-09 5. Longest Palindromic Substring</h3>

<p>Given a string <code class="language-plaintext highlighter-rouge">s</code>, return <em>the longest palindromic substring</em> in <code class="language-plaintext highlighter-rouge">s</code>.</p>

<p>一开始的思路：回文的特点是：正着读和反着读是一模一样的，所以根据这个特性，给定一个string s，把他reverse一下变成s’，然后找s和s’的longest common substring就好了，但因为这样子的话会忽略一个case：$abcxicba$,这样子的话，reverse了之后，s’有和原string的abc match了，但这明显不是valid的回文，因为match的原因是因为原string含有abc的reversed version，所以必须要先确定位置，但这题在实现上有一点问题 <a href="#5. Longest Palindromic Substring Code">code</a></p>

<p>改进的思路</p>

<h3 id="九章算法">九章算法</h3>

<h3 id="2021-11-24-lintcode-56-两数之和">2021-11-24 Lintcode: 56. 两数之和</h3>

<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function <code class="language-plaintext highlighter-rouge">twoSum</code> should return <code class="language-plaintext highlighter-rouge">indices</code> of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are zero-based.</p>

<p>本来的思路：老生常谈的two sum问题还是磕磕碰碰的。还是一样的思想：双指针，然后一个指向左一个指向右，根据目前两个指针指向的index加起来的值和target值做对比从而得出该移动左指针还是右指针。现在的问题是，双指针的思路是记住了，但是忽视了双指针只作用于sort好的array上，这是第一，第二点就是在sort完之后，index改了，需要用到一个数据结构去记录这个index <a href="#2021-10-19: 1. Two Sum Code">代码</a></p>

<p>改进的思路：</p>

<h3 id="2021-11-24-lintcode-104-合并k个排序链表">2021-11-24 Lintcode: 104. 合并k个排序链表</h3>

<p>Merge k sorted linked lists and return it as one sorted list.</p>

<p>Analyze and describe its complexity.</p>

<p>样例</p>

<p><strong>Example 1:</strong></p>

<p>Input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lists = [2-&gt;4-&gt;null,null,-1-&gt;null]
</code></pre></div></div>

<p>Output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-1-&gt;2-&gt;4-&gt;null
</code></pre></div></div>

<p>Explanation:</p>

<p>Merge 2-&gt;4-&gt;null, nulll and -1-&gt;null into an ascending list.</p>

<p>一开始的思路: 实现一个可以合并两个链表的方程，然后一个一个的合并list中的链表，问题就是时间复杂度会很高，但被accept了。反思是在写代码的时候，对于是新建一个全新的object还是在原有的结构上改变很模糊，要复习并且学习java的关于这方面的知识<a href="#2021-11-24 Lintcode: 104. 合并k个排序链表 Code">code</a></p>

<p>改进的思路</p>

<h3 id="20211124-lintcode-102--带环链表">2021.11.24 Lintcode: 102 · 带环链表</h3>

<p>描述</p>

<p>Given a linked list, determine if it has a cycle in it.</p>

<p>The length of the linked list does not exceed 10000.</p>

<p>样例</p>

<p><strong>Example 1:</strong></p>

<p>Input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linked list = 21-&gt;10-&gt;4-&gt;5，then tail connects to node index 1(value 10).
</code></pre></div></div>

<p>Output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>true
</code></pre></div></div>

<p>Explanation:</p>

<p>The linked list has rings.</p>

<p>一开始的思路：无思路</p>

<p>更好的思路：两个指针，一个快指针，一个慢指针，快指针一次跳两格，慢指针一次跳一格，如果存在cycle的话，快慢指针必定相遇 <a href="#2021.11.24: 102 · 带环链表 Code">code</a></p>

<h3 id="2021-11-25-lintcode-94--binary-tree-maximum-path-sum">2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum</h3>

<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>

<p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p>

<p>Given the <code class="language-plaintext highlighter-rouge">root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>

<p>一开始的思路：使用recursion，在每一步，尝试对比：root+左，root+右和root+左+右。但这样子会有问题，因为在这样的算法下，他不能避免不是path的情况，path的定义是：A node can only appear in the sequence <strong>at most once</strong>，如下图</p>

<p><img src="/Users/michaelma/Desktop/Workspace/Screenshots/Snipaste_2021-11-25_12-40-06.png" alt="Snipaste_2021-11-25_12-40-06" style="zoom:50%;" /></p>

<p>在这一题里，-10的root node的右树的最大的path是：15 20 7，并且这个最大的path是会被记录下来的，这样子-10会理所当然认为结果就是一个存在-10 15 20 7这些node的path，但很明显这不构成path。实际上错误的点在于，我要找一个path，我只能一次探索一个方向，切不可两个方向都探索，root+左+右这样是完全不存在的。</p>

<p>改进的思路：应该调整思路，我们探索整张图的只走左或者只走右的路径，如果要探索root+左+右的话，我们只能假设目前recur到的位置就是开启一个新的path的root，而不能把这个当作一个探索的思路去返还给上一层。所以我们的主函数依然是只探索一个方向的path的最大，但是在探索的过程中，我们时刻记录着以各个node为root的最大，最后对比并且返还 <a href="#2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum Code">code</a></p>

<h3 id="2021-11-25-lintcode-94--binary-tree-maximum-path-sum-1">2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum</h3>

<p>Given an integer array <code class="language-plaintext highlighter-rouge">nums</code>, return the length of the longest strictly increasing subsequence.</p>

<p>A <strong>subsequence</strong> is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, <code class="language-plaintext highlighter-rouge">[3,6,2,7]</code> is a subsequence of the array <code class="language-plaintext highlighter-rouge">[0,3,1,6,2,2,7]</code>.</p>

<p>一开始的思路：接受事实，dp就是$n^2$的玩意儿。用dp的思想去做，从前往后扫过所有的元素，每一步，检查之前存下来的信息的array，dpRes就是信息的array，dpRes[i]-&gt;{val, max}代表了：第i个元素，有着val值，并且拥有以他为最后一个的最长升序的序列长度，那么我每扫过一个element，我都在这个dpRes[0, i]里面找：val小于目前的元素，且max最大的。但似乎不算很正常的dp？？<a href="#2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum Code">code</a></p>

<p>改进的思路：</p>

<h3 id="2021-11-25-lintcode-45--maximum-subarray-difference-code">2021-11-25 Lintcode: 45 · Maximum Subarray Difference Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * @param nums: A list of integers
     * @return: An integer indicate the value of maximum difference between two substrings
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxDiffSubArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// write your code here</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftMin</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">rightMin</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        
        
        <span class="kt">int</span> <span class="n">minSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">minSum</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">minSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">minSum</span><span class="o">);</span>
            <span class="n">leftMax</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">maxSum</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">maxSum</span><span class="o">);</span>
            <span class="n">leftMin</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">minSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">minSum</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
            <span class="n">minSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">minSum</span><span class="o">);</span>
            <span class="n">rightMax</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
            
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">sum</span> <span class="o">-</span> <span class="n">maxSum</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
            <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">sum</span><span class="o">,</span> <span class="n">maxSum</span><span class="o">);</span>
            <span class="n">rightMin</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">candidate1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">leftMin</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">-</span> <span class="n">rightMax</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
            <span class="kt">int</span> <span class="n">candidate2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">leftMax</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">-</span> <span class="n">rightMin</span><span class="o">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">candidate1</span> <span class="o">,</span> <span class="n">candidate2</span><span class="o">));</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="thought-end-pointer">Thought End Pointer</h4>

<p><a href="#Code End Pointer">Code End Pointer</a></p>

<p><a href="#目录">回到目录</a></p>

<h2 id="code">Code</h2>

<h3 id="2021-10-14-56-merge-intervals-code">2021-10-14: 56. Merge Intervals Code</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">mergeResult</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">sortedIntervals</span> <span class="o">=</span> <span class="n">getSortedIntervals</span><span class="o">(</span><span class="n">intervals</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sortedIntervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">sortedIntervals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">sortedIntervals</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="c1">//mergeable, update current node -&gt; [a, b], [c, d] -&gt; a&lt;c, a&lt;b, c&lt;d -&gt; b&gt;c, a&lt;c, a&lt;b, c&lt;d -&gt; the </span>
                <span class="c1">//infomation between b and d is not given and we always care about the smallest and largest valu of</span>
                <span class="c1">//the range</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currentNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">sortedIntervals</span><span class="o">[</span><span class="n">ptr</span><span class="o">][</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
                    <span class="c1">//make sure the current node is being updated to most representitive range</span>
                    <span class="n">currentNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">sortedIntervals</span><span class="o">[</span><span class="n">ptr</span><span class="o">][</span><span class="mi">1</span><span class="o">]?</span><span class="n">currentNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]:</span><span class="n">sortedIntervals</span><span class="o">[</span><span class="n">ptr</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                    <span class="n">ptr</span><span class="o">++;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//if the current range can't reach the next one, break</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="nc">List</span> <span class="n">currentNodeList</span> <span class="o">=</span> <span class="n">toList</span><span class="o">(</span><span class="n">currentNode</span><span class="o">);</span>
            <span class="n">mergeResult</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentNodeList</span><span class="o">);</span>
            <span class="c1">//There are two ways to get out from the while:(1) next one is non-reachable, then we need to start examine</span>
            <span class="c1">//the next node (2) the ptr has already reached the end of the array, and we don't have more nodes to examine</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">get2dArray</span><span class="o">(</span><span class="n">mergeResult</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">toList</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">currentNode</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">currentNode</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">resultList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentNode</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">resultList</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">get2dArray</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">resultArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()][</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">interval</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">size</span><span class="o">()];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++){</span>
                <span class="n">interval</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">resultArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">interval</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">resultArray</span><span class="o">;</span>
        
    <span class="o">}</span>
    
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">getSortedIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">){</span>
        <span class="c1">//base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">intervals</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">leftEndsOn</span> <span class="o">=</span> <span class="n">leftLength</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">leftLength</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLength</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">sortedFinal</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">leftEndsOn</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">rightPtr</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort each</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">getSortedIntervals</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">getSortedIntervals</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sortedFinal</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">sortedFinal</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">];</span>
                <span class="n">rightPtr</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sortedFinal</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">];</span>
                <span class="n">leftPtr</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">sortedFinal</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">];</span>
                <span class="n">leftPtr</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">sortedFinal</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">];</span>
                <span class="n">rightPtr</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sortedFinal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-14-1818-minimum-absolute-sum-difference-code">2021-10-14: 1818. Minimum Absolute Sum Difference Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minAbsoluteSumDiff</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">resultList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">diff</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">newNums1</span> <span class="o">=</span> <span class="n">replace</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums1</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]);</span>
                <span class="n">resultList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">diff</span><span class="o">(</span><span class="n">newNums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span>
                <span class="n">leftPtr</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">newNums1</span> <span class="o">=</span> <span class="n">replace</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">nums1</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]);</span>
                <span class="n">resultList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">diff</span><span class="o">(</span><span class="n">newNums1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">));</span>
                <span class="n">rightPtr</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">rightPtr</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">resultList</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">resultList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">%</span> <span class="mi">1000000007</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">diff</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;=</span><span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]?(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]):(-</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">local</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">replace</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toBeReplacedIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">newInstance</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="n">newInstance</span><span class="o">[</span><span class="n">toBeReplacedIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">newInstance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-15-2007-find-original-array-from-doubled-array-1">2021-10-15: 2007. Find Original Array From Doubled Array</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findOriginalArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">changed</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">changed</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">// 2*(100000+1) because we want to store all possible value from</span>
        <span class="c1">// 0-10**5 and the double of the value</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">countingTable</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">*(</span><span class="mi">100000</span><span class="o">+</span><span class="mi">1</span><span class="o">)],</span> <span class="n">resultArr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">changed</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">changedIndex</span> <span class="o">:</span> <span class="n">changed</span><span class="o">){</span>
            <span class="c1">//basically, we now record the occurrences for each value</span>
            <span class="n">countingTable</span><span class="o">[</span><span class="n">changedIndex</span><span class="o">]++;</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">countingTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">countingTable</span><span class="o">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">]</span> <span class="o">-=</span> <span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">resultArr</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="n">countingTable</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>
                    <span class="n">ptr</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">resultArr</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-16-253-meeting-rooms-ii-code">2021-10-16: 253. Meeting Rooms II Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minMeetingRooms</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">earliestEndingRoom</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">intervalsCloneSorted</span> <span class="o">=</span> <span class="n">sortIntervals</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">clone</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">meeting</span> <span class="o">:</span> <span class="n">intervalsCloneSorted</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">meeting</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="kt">int</span> <span class="n">earliestEndingMeetingTime</span> <span class="o">=</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">earliestEndingMeetingTime</span> <span class="o">&lt;=</span> <span class="n">meeting</span><span class="o">[</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="c1">//the earliest room will be prepared, we will use that</span>
                    <span class="kt">int</span> <span class="n">toBeReplaceTime</span> <span class="o">=</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="kt">boolean</span> <span class="n">added</span> <span class="o">=</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">meeting</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//the room is not empty and we can't use that, need to allocate a new room</span>
                    <span class="kt">boolean</span> <span class="n">added</span> <span class="o">=</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">meeting</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">earliestEndingRoom</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">sortIntervals</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">){</span>
        <span class="c1">//base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">intervals</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++]</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">sortIntervals</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">sortIntervals</span><span class="o">(</span><span class="n">right</span><span class="o">),</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">leftCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//merge</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftCount</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="c1">//when all the value from left has been used, we continue to increment right</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightCount</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="c1">//when all the value from right has been used, we continue to increment left</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftCount</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftCount</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightCount</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftCount</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftCount</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightCount</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-17-75-sort-colors-code">2021-10-17: 75. Sort Colors Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="c1">//base</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">leftLength</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLength</span><span class="o">],</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftLength</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-17-147-insertion-sort-list-code">2021-10-17: 147. Insertion Sort List Code</h3>

<h3 id="2021-10-18-215-kth-largest-element-in-an-array-code">2021-10-18: 215. Kth Largest Element in an Array Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findKthLargest</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// sort the arr in desc order</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="c1">//base case</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">leftLength</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLength</span><span class="o">],</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftLength</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//merge</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-18-973-k-closest-points-to-origin-code">2021-10-18: 973. K Closest Points to Origin Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">kClosest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">pointsWithDist</span> <span class="o">=</span> <span class="n">getDistForPoints</span><span class="o">(</span><span class="n">points</span><span class="o">);</span>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">pointsWithDistSorted</span> <span class="o">=</span> <span class="n">mergeSortPoints</span><span class="o">(</span><span class="n">pointsWithDist</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">copyToArray</span><span class="o">(</span><span class="n">pointsWithDistSorted</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getDist</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
        <span class="kt">double</span> <span class="n">term1</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="n">term2</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">((</span><span class="n">term1</span><span class="o">+</span><span class="n">term2</span><span class="o">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">);</span>
        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">double</span><span class="o">[][]</span> <span class="nf">getDistForPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">points</span><span class="o">){</span>
        <span class="c1">//return [xi, yi, disti] for each points</span>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">pointsWithDist</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">pointsWithDist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">pointsWithDist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">pointsWithDist</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">getDist</span><span class="o">(</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pointsWithDist</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">double</span><span class="o">[][]</span> <span class="nf">mergeSortPoints</span><span class="o">(</span><span class="kt">double</span><span class="o">[][]</span> <span class="n">points</span><span class="o">){</span>
        <span class="c1">//base</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">points</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">leftLength</span><span class="o">][</span><span class="mi">3</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">rightLength</span><span class="o">][</span><span class="mi">3</span><span class="o">],</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftLength</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">double</span><span class="o">[][]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">mergeSortPoints</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">mergeSortPoints</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">2</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">2</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">copyToArray</span><span class="o">(</span><span class="kt">double</span><span class="o">[][]</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">points</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-19-1-two-sum-code">2021-10-19: 1. Two Sum Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">valPos</span> <span class="o">=</span> <span class="n">getValPos</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">sortedNums</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">valPos</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">sortedNums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">sortedNums</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">sortedNums</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">sortedNums</span><span class="o">[</span><span class="n">left</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">sortedNums</span><span class="o">[</span><span class="n">right</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">getValPos</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="c1">//base</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split </span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">leftLength</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLength</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">,</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftLength</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-19-15-3sum-code">2021-10-19: 15. 3sum Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//quickSort(nums, 0, nums.length-1);</span>
        <span class="c1">//Arrays.sort(nums);</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="n">getTwoSumResult</span><span class="o">(</span><span class="mi">0</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">rightPtr</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
                <span class="c1">//if there are no according two sum result</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getTwoSumResult</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="n">endIndex</span><span class="o">;</span>
        <span class="c1">//int[] result = new int[2];</span>
        <span class="kt">boolean</span> <span class="n">isExistResult</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&lt;</span> <span class="n">rightPtr</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">localList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">localList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++]);</span>
                <span class="n">localList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">--]);</span>
                <span class="n">localList</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="n">target</span><span class="o">);</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">localList</span><span class="o">);</span>
                <span class="n">isExistResult</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&lt;</span> <span class="n">rightPtr</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">leftPtr</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]){</span>
                    <span class="o">++</span><span class="n">leftPtr</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="o">--</span><span class="n">rightPtr</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="o">++</span><span class="n">leftPtr</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="c1">//base</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//split</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">mergeSort</span><span class="o">(</span><span class="n">right</span><span class="o">),</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">&gt;=</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">&gt;=</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            
            <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                    <span class="n">i</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            
            <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-19-18-4sum-code">2021-10-19: 18. 4sum Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">fourSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//sort</span>
        <span class="c1">//nums = mergeSort(nums);</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>
        <span class="c1">//traverse</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">threeSum</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">threeSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fourAdd</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">){</span>
        <span class="c1">//find all unique three sum tuple from nums</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">startIndex</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">twoSum</span><span class="o">(</span><span class="n">target</span><span class="o">-</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">fourAdd</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">res</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fourAdd</span><span class="o">,</span> <span class="kt">int</span> <span class="n">threeAdd</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="o">){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">localResult</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">localResult</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">fourAdd</span><span class="o">);</span>
                <span class="n">localResult</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">threeAdd</span><span class="o">);</span>
                <span class="n">localResult</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>
                <span class="n">localResult</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>
                <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">localResult</span><span class="o">);</span>
                <span class="n">left</span><span class="o">++;</span>
                <span class="n">right</span><span class="o">--;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">right</span><span class="o">--;</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">){</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-19-767-reorganize-string-code">2021-10-19: 767. Reorganize String Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reorganizeString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">occurMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">targetLength</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">targetLength</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">occurMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">occurMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">occurPair</span> <span class="o">:</span> <span class="n">occurMap</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">occurPair</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">StringBuilder</span> <span class="n">sBuild</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        
        <span class="k">while</span> <span class="o">(</span><span class="n">sBuild</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">targetLength</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sBuild</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="c1">//the first element</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">currentLargest</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sBuild</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                <span class="n">currentLargest</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">currentLargest</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sBuild</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">sBuild</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">currentLargest</span><span class="o">.</span><span class="na">getKey</span><span class="o">()){</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
                    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                        <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">secondLargest</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                        <span class="n">sBuild</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">secondLargest</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                        <span class="n">secondLargest</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">secondLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">secondLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">secondLargest</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">sBuild</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                    <span class="n">currentLargest</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">currentLargest</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                        <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">currentLargest</span><span class="o">);</span>
                <span class="o">}</span>   
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">sBuild</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-22-1152-analyze-user-website-visit-pattern-code">2021-10-22: 1152. Analyze User Website Visit Pattern Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">mostVisitedPattern</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">username</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">timestamp</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">website</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Visit</span><span class="o">&gt;</span> <span class="n">visitList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timestamp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">visitList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Visit</span><span class="o">(</span><span class="n">username</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">timestamp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">website</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="o">}</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">visitList</span><span class="o">,</span> <span class="o">(</span><span class="nc">Visit</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Visit</span> <span class="n">v2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">v1</span><span class="o">.</span><span class="na">time</span> <span class="o">-</span> <span class="n">v2</span><span class="o">.</span><span class="na">time</span><span class="o">);</span>
        
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">visitMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">visitList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">valueArr</span> <span class="o">=</span> <span class="n">visitMap</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">visitList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">user</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;());</span>
            <span class="n">valueArr</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">visitList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">web</span><span class="o">);</span>
            <span class="n">visitMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">visitList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">user</span><span class="o">,</span> <span class="n">valueArr</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">//construct the user -&gt; patterns map</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">patternMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">user</span> <span class="o">:</span> <span class="n">visitMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">history</span> <span class="o">=</span> <span class="n">visitMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">patterns</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">history</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">history</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">history</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">k</span><span class="o">++){</span>
                        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">splitPattern</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span>
                            <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span>
                            <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">),</span>
                            <span class="n">history</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">),</span>
                        <span class="o">});</span>
                        <span class="n">patterns</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">getPatternString</span><span class="o">(</span><span class="n">splitPattern</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">patternMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">patterns</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">//constructing the pattern -&gt; occurrences map and the priority queue</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">patternCompare</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry2</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">entry1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="n">entry2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()){</span>
                    <span class="c1">//if there are exactly the same occurrences</span>
                  	<span class="c1">//这里用entry1.compareTo(entry2)的原因是因为我们本来就desire的是更小的lexi order的string</span>
                  	<span class="c1">//而下面之所以要换成-(e1-e2) = e2 - e1的原因在于我们desire更大的score，pq存放的东西本来就是</span>
                  	<span class="c1">//小到大，用e2-e1本就属于要令pq存放大到小的无奈之举。compareTo的结果本就是我们desire的</span>
                    <span class="k">return</span> <span class="n">entry1</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">entry2</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">entry2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">entry1</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">user</span> <span class="o">:</span> <span class="n">patternMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">()){</span>
            <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">patterns</span> <span class="o">=</span> <span class="n">patternMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">pattern</span> <span class="o">:</span> <span class="n">patterns</span><span class="o">){</span>
                <span class="n">patternCompare</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="n">patternCompare</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">patternCompare</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">().</span><span class="na">getKey</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">));</span>
    <span class="o">}</span>
    
   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPatternString</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">jointList</span><span class="o">){</span>
       <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="n">jointList</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Visit</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">user</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">time</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">web</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Visit</span><span class="o">(</span><span class="nc">String</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">,</span> <span class="nc">String</span> <span class="n">w</span><span class="o">){</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">u</span><span class="o">;</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="n">web</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="621-task-scheduler-code">621. Task Scheduler code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">taskOccur</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">sbMax</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">n</span><span class="o">*(</span><span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="n">taskOccur</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">taskOccur</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">taskOccur</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        
        <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">){</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                <span class="n">taskOccur</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">taskOccur</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">())-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">while</span> <span class="o">(!(</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()||</span><span class="n">okToAdd</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">sb</span><span class="o">,</span> <span class="n">n</span><span class="o">))){</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">okToAdd</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">sb</span><span class="o">,</span> <span class="n">n</span><span class="o">)){</span>
                    <span class="c1">//candidate is ready to use</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                    <span class="n">taskOccur</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">taskOccur</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="na">getKey</span><span class="o">())-</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="c1">//there is no right key, add idle</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="sc">'i'</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">resumePQ</span><span class="o">(</span><span class="n">taskOccur</span><span class="o">,</span> <span class="n">pq</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">okToAdd</span><span class="o">(</span><span class="nc">Character</span> <span class="n">candidate</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">candidate</span><span class="o">.</span><span class="na">charValue</span><span class="o">()){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">resumePQ</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">taskOccur</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="o">){</span>
        <span class="n">pq</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">taskOccur</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="621-task-scheduler-better-code">621. Task Scheduler better code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leastInterval</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">tasks</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">tasks</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nextValid</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">size</span><span class="o">()],</span> <span class="n">rest</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">size</span><span class="o">()];</span>
        <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="c1">//since every task can be place on the first position</span>
            <span class="n">nextValid</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">rest</span><span class="o">[</span><span class="n">ptr</span><span class="o">]</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">ptr</span><span class="o">++;</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tasks</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="o">++</span><span class="n">time</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">minNextValid</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nextValid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">rest</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">minNextValid</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minNextValid</span><span class="o">,</span> <span class="n">nextValid</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="n">time</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">time</span><span class="o">,</span> <span class="n">minNextValid</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">maxRest</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">nextAvailableIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nextValid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nextValid</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">time</span> <span class="o">&amp;&amp;</span> <span class="n">rest</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                    <span class="n">nextAvailableIndex</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxRest</span><span class="o">,</span> <span class="n">rest</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">==</span> <span class="n">maxRest</span><span class="o">?</span><span class="nl">nextAvailableIndex:</span><span class="n">j</span><span class="o">;</span>
                    <span class="n">maxRest</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxRest</span><span class="o">,</span> <span class="n">rest</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">nextValid</span><span class="o">[</span><span class="n">nextAvailableIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">nextValid</span><span class="o">[</span><span class="n">nextAvailableIndex</span><span class="o">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">rest</span><span class="o">[</span><span class="n">nextAvailableIndex</span><span class="o">]--;</span>
        <span class="o">}</span>
        
        
        <span class="k">return</span> <span class="n">time</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-26-692-top-k-frequent-words-code">2021-10-26: 692. Top K Frequent Words code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">e1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">e2</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()){</span>
                    <span class="c1">//lexi</span>
                    <span class="k">return</span> <span class="n">e1</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">e2</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="o">-(</span><span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
       <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
           <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
       <span class="o">}</span>
        
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
           <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">().</span><span class="na">getKey</span><span class="o">());</span>
       <span class="o">}</span>
        
       <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-27-347-top-k-frequent-elements-code">2021-10-27: 347. Top K Frequent Elements code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">freq</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">freq</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">e1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">e2</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">e2</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">-</span> <span class="n">e1</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">freq</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">//poll from pq</span>
            <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">().</span><span class="na">getKey</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-10-27-1647-minimum-deletions-to-make-character-frequencies-unique-code">2021-10-27: 1647. Minimum Deletions to Make Character Frequencies Unique code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDeletions</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">charArray</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">charArray</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">freqSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">charArray</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">charArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">charArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">charArray</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">ch</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">charArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">charArray</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">ch</span><span class="o">){</span>
                    <span class="kt">int</span> <span class="n">newFreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">;</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">freqSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">freq</span><span class="o">)){</span>
                        <span class="o">--</span><span class="n">freq</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">?</span><span class="n">res</span> <span class="o">+</span> <span class="o">(</span><span class="n">newFreq</span> <span class="o">-</span> <span class="n">freq</span><span class="o">):</span><span class="n">res</span> <span class="o">+</span> <span class="n">newFreq</span><span class="o">;</span>
                    <span class="n">freqSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
                    <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">freqSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">freq</span><span class="o">)){</span>
                        <span class="n">res</span><span class="o">++;</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="kt">int</span> <span class="n">newFreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">;</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">freqSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">freq</span><span class="o">)){</span>
                        <span class="o">--</span><span class="n">freq</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">?</span><span class="n">res</span> <span class="o">+</span> <span class="o">(</span><span class="n">newFreq</span> <span class="o">-</span> <span class="n">freq</span><span class="o">):</span><span class="n">res</span> <span class="o">+</span> <span class="n">newFreq</span><span class="o">;</span>
                    <span class="n">freqSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
                    <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">charArray</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">charArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">charArray</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">ch</span><span class="o">){</span>
                <span class="o">++</span><span class="n">freq</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">charArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">newFreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">freqSet</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">freq</span><span class="o">)){</span>
                    <span class="o">--</span><span class="n">freq</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">?</span><span class="n">res</span> <span class="o">+</span> <span class="o">(</span><span class="n">newFreq</span> <span class="o">-</span> <span class="n">freq</span><span class="o">):</span><span class="n">res</span> <span class="o">+</span> <span class="n">newFreq</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-11-08-912-sort-an-array-code">2021-11-08: 912. Sort an Array Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sortArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//base</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//div</span>
        <span class="kt">int</span> <span class="n">leftLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">rightLength</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">leftLength</span><span class="o">,</span> <span class="n">rightCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">leftLength</span><span class="o">],</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rightLength</span><span class="o">],</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftLength</span><span class="o">){</span>
                <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">right</span><span class="o">[</span><span class="n">rightCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//sort</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">leftSorted</span> <span class="o">=</span> <span class="n">sortArray</span><span class="o">(</span><span class="n">left</span><span class="o">),</span> <span class="n">rightSorted</span> <span class="o">=</span> <span class="n">sortArray</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
        <span class="c1">//merge</span>
        <span class="kt">int</span> <span class="n">leftPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">rightPtr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftPtr</span> <span class="o">==</span> <span class="n">leftSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightPtr</span> <span class="o">==</span> <span class="n">rightSorted</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">leftSorted</span><span class="o">[</span><span class="n">leftPtr</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">]){</span>
                <span class="n">res</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightSorted</span><span class="o">[</span><span class="n">rightPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="c1">//</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="5-longest-palindromic-substring-code">5. Longest Palindromic Substring Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span>
        <span class="c1">//Queue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((e1, e2) -&gt; e2.getValue() - e1.getValue());</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">"abb"</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">old</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">(),</span> <span class="n">reverse</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">old</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="c1">//reverse</span>
        <span class="kt">int</span> <span class="n">lastOldIndex</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reverse</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">reverse</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">old</span><span class="o">[</span><span class="n">lastOldIndex</span> <span class="o">-</span> <span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">//compare</span>
        <span class="k">return</span> <span class="nf">findTheValidLongestSubsequence</span><span class="o">(</span><span class="n">old</span><span class="o">,</span> <span class="n">reverse</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">findTheValidLongestSubsequence</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">old</span><span class="o">,</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">reverse</span><span class="o">){</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">reverse</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">reverse</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">concat</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="n">i</span><span class="o">])));</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">).</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="o">){</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                    <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
                <span class="o">}</span>
                
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">!=</span> <span class="s">""</span><span class="o">?</span><span class="nl">result:</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">old</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-11-24-lintcode-104-合并k个排序链表-code">2021-11-24 Lintcode: 104. 合并k个排序链表 Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */</span> 
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">mergeKLists</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">ListNode</span><span class="o">&gt;</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>  
        <span class="c1">// write your code here</span>
        <span class="nc">ListNode</span> <span class="n">res</span> <span class="o">=</span> <span class="n">lists</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lists</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">lists</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">merge</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">res</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">ln2</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ln2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">ln2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">ln2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">ln1Ptr</span> <span class="o">=</span> <span class="n">res</span><span class="o">,</span> <span class="n">ln2Ptr</span> <span class="o">=</span> <span class="n">ln2</span><span class="o">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">tempPtr</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">ln1Ptr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ln2Ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ln1Ptr</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">ln2Ptr</span><span class="o">.</span><span class="na">val</span><span class="o">){</span>
                <span class="nc">ListNode</span> <span class="n">tempListNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">ln1Ptr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tempListNode</span><span class="o">;</span>
                <span class="n">tempPtr</span> <span class="o">=</span> <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">ln1Ptr</span> <span class="o">=</span> <span class="n">ln1Ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="nc">ListNode</span> <span class="n">tempListNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">ln2Ptr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tempListNode</span><span class="o">;</span>
                <span class="n">tempPtr</span> <span class="o">=</span> <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">ln2Ptr</span> <span class="o">=</span> <span class="n">ln2Ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">ln1Ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">tempListNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">ln1Ptr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tempListNode</span><span class="o">;</span>
            <span class="n">tempPtr</span> <span class="o">=</span> <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">ln1Ptr</span> <span class="o">=</span> <span class="n">ln1Ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">ln2Ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">tempListNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">ln2Ptr</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tempListNode</span><span class="o">;</span>
            <span class="n">tempPtr</span> <span class="o">=</span> <span class="n">tempPtr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">ln2Ptr</span> <span class="o">=</span> <span class="n">ln2Ptr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="20211124-102--带环链表-code">2021.11.24: 102 · 带环链表 Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="cm">/**
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-11-25-lintcode-94--binary-tree-maximum-path-sum-code">2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">gain</span> <span class="o">=</span> <span class="n">maxGain</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">gain</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxGain</span><span class="o">(</span><span class="nc">TreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">leftGain</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxGain</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightGain</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxGain</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">priceNewPath</span> <span class="o">=</span> <span class="n">leftGain</span> <span class="o">+</span> <span class="n">rightGain</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="n">maxSum</span> <span class="o">=</span> <span class="n">priceNewPath</span> <span class="o">&gt;=</span> <span class="n">maxSum</span> <span class="o">?</span> <span class="n">priceNewPath</span> <span class="o">:</span> <span class="n">maxSum</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">leftGain</span><span class="o">,</span> <span class="n">rightGain</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h4 id="code-end-pointer">Code End Pointer</h4>

<h3 id="2021-11-25-lintcode-94--binary-tree-maximum-path-sum-code-1">2021-11-25 Lintcode: 94 · Binary Tree Maximum Path Sum Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dpRes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">generateDP</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">dpRes</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">info</span> <span class="o">:</span> <span class="n">dpRes</span><span class="o">){</span>
            <span class="n">maxVal</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxVal</span><span class="o">,</span> <span class="n">info</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">maxVal</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateDP</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dpRes</span><span class="o">){</span>
        <span class="n">dpRes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="mi">1</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">localMax</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">dpRes</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">]){</span>
                    <span class="n">localMax</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">localMax</span><span class="o">,</span> <span class="n">dpRes</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">dpRes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">localMax</span><span class="o">,</span> <span class="mi">1</span><span class="o">)};</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2021-11-25-lintcode-45--maximum-subarray-difference">2021-11-25 Lintcode: 45 · Maximum Subarray Difference</h3>

<p>Given an array with integers.</p>

<table>
  <tbody>
    <tr>
      <td>Find two <em>non-overlapping</em> subarrays <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>, which</td>
      <td>SUM(A) - SUM(B)</td>
      <td>∣<em>S<strong>U</strong>M</em>(<em>A</em>)−<em>S<strong>U</strong>M</em>(<em>B</em>)∣ is the largest.</td>
    </tr>
  </tbody>
</table>

<p>Return the largest difference.</p>

<p>一开始的思路：</p>

<p>改进的思路：<a href="#2021-11-25 Lintcode: 45 · Maximum Subarray Difference Code">code</a></p>

<p><a href="#Thought End Pointer">Thought</a></p>

<p><a href="#目录">回到目录</a></p>

<h2 id="九章算法-1">九章算法</h2>

<h3 id="2021-11-24">2021-11-24</h3>

<ul>
  <li></li>
</ul>

<h2 id="others">Others</h2>

<h3 id="急需解决">急需解决</h3>

<ul>
  <li>task scheduler的代码里，为何把time++放在28行和最后的结果完全不一样？</li>
</ul>

<h3 id="review">[Review]</h3>

<ul>
  <li>binary search for all the search</li>
  <li>just sort() it
    <ul>
      <li>Java的array sort是按照ascending的格式来sort的
        <ul>
          <li>怎么变成descending的格式？</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>简单的快排真的垃圾</li>
  <li>如果可以的话，尽可能的在一个arr上进行改动，rather than不停的赋值新的arr</li>
  <li>map.getOrDefault(Object key, V defaultValue): 尝试从一个map中access一个value，如果没有这个key的话，就返还一个自己设定的default</li>
  <li>comparator: <code class="language-plaintext highlighter-rouge">Comparator&lt;Player&gt; comparator = (p1, p2) -&gt; p1.getRanking() - p2.getRanking();</code>
    <ul>
      <li>快速新建comparator的方法，可以直接用在priority queue的initialization里</li>
      <li>后面这个方法实际上就是实现了compare这个方法：
        <ul>
          <li>Compares its two arguments for order. <strong>Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.</strong></li>
        </ul>
      </li>
      <li>实例化pq的例子是：<code class="language-plaintext highlighter-rouge">Queue&lt;E&gt; pq = new PriorityQueue&lt;(e1, e2) -&gt; e1.field - e2.field&gt;//如果按照从小到大的顺序来排序的话</code></li>
    </ul>
  </li>
  <li>需要注意的是，priority queue的头是least element，所以如果想令他的头是most element的话，需要manipulate一下comparator：
    <ul>
      <li>之前要实现的是 int compare(e1, e2)，当返还-的时候，pq认为e1比e2小，然后把e1丢在了前面，但是我们希望把e2丢前面，那么就negate一下结果就好</li>
      <li>理解如果design compare的时候，我们要和需要用到comparator的东西相结合。比如pq，compare返还负数的时候，compare会把e1给排在e2前面（因为e1 - e2 &lt; 0），如果e1和e2各有一个value，我们想把更大的值放在前面的话，我们就需要用-(e1.val - e2.val)。</li>
    </ul>
  </li>
  <li>StringBuilder在lang中</li>
  <li>那种带有很多个field，然后需要排序的东西，比较好的做法是把他们封装成一个类，然后调用collections.sort去sort <a href="2021-10-22: 1152. Analyze User Website Visit Pattern Code">code</a>像这样，然后这样的类直接定义在solution class一个级别 class 什么什么就好了</li>
</ul>

<h3 id="pythonsort-dictionary-by-value-python">[python]sort dictionary by value python:</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
  <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
  
  <span class="ow">or</span>
  
  <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="o">-&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">)]</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="pythonregular-expression">[python]Regular Expression</h3>

<ul>
  <li>
    <p>raw string is a string prefix with a r: not to handle back slash in any way(no escaping)</p>

    <ul>
      <li>所以’\ttab’和r’\ttab’是不一样的，前者会处理backslash</li>
      <li>case sensitive</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.       - Any Character Except New Line
\d      - Digit (0-9)
\D      - Not a Digit (0-9)
\w      - Word Character (a-z, A-Z, 0-9, _)
\W      - Not a Word Character
\s      - Whitespace (space, tab, newline)
\S      - Not Whitespace (space, tab, newline)
    
\b      - Word Boundary
\B      - Not a Word Boundary
^       - Beginning of a String
$       - End of a String
    
[]      - Matches Characters in brackets
[^ ]    - Matches Characters NOT in brackets
|       - Either Or
( )     - Group
    
Quantifiers:
*       - 0 or More
+       - 1 or More
?       - 0 or One
{3}     - Exact Number
{3,4}   - Range of Numbers (Minimum, Maximum)
    
    
#### Sample Regexs ####
    
[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+
</code></pre></div>    </div>
  </li>
  <li>
    <p>re.search</p>

    <ul>
      <li>scan through the whole string and look for the <strong>FIRST</strong> match, and return the match object. Return None if no position in the string matches the pattern.
        <ul>
          <li>match: https://docs.python.org/3/library/re.html#match-objects</li>
          <li>一般来说，只要用<code>match.group(0)</code>就可以得到具体的match</li>
        </ul>
      </li>
      <li>Match with group: 在pattern里，用()括号括起来的就是一个group，在识别的时候，不仅把符合pattern的目标识别出来，还会把目标中具体的不同的group的信息识别出来，比如我的pattern是<code>r"(\w\*)([2-3]\*)"</code>，那么就知道前面的字母是一个组，而后面的数字是一个组，那么一个识别出来的target string: “abc222”，用group(1)可以得到abc，group(2)可以得到222</li>
    </ul>
  </li>
</ul>

<h3 id="java-regex">[Java] Regex</h3>

<h3 id="latex并列图片">[latex]并列图片</h3>

<h3 id="codehow-to-read-java-doc-python-doc">[code]How to read java doc, python doc?</h3>

<ul>
  <li>use java se documentation kit，很多东西都在base里
    <ul>
      <li>use指的是usage of the (this) class</li>
    </ul>
  </li>
</ul>

<h3 id="java-bitwise--and-decide-if-the-number-is-oddeven">[Java] bitwise &amp; and decide if the number is odd/even</h3>

<ul>
  <li>The bitwise &amp; operator 把两个operands的两边的bit表示拉取出来，一个bit一个bit的用&amp;去比，会得出一个新的数字</li>
  <li>decide if the number is odd/even:
    <ol>
      <li>模2，看看结果是不是0</li>
      <li>&amp; 1，看看结果是不是1
        <ul>
          <li>因为1的bit是r’0*1’，所以最后一位必定是1，前面都是0，所以前面的结果肯定都是0，因为0不管和谁&amp;结果都是0，而最后一位，只有奇数的最后一位必定是1，所以奇数和1&amp;必定是1</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="java-arrayscopyarray">[Java] Arrays.copy(array)</h3>

<h3 id="java-k">[Java] k++</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">k++</code> increases the value of <code class="language-plaintext highlighter-rouge">k</code>, but returns the <strong>previous</strong> value. 他会在所有基于k的操作都结束的时候再增加k的值
    <ul>
      <li>即使是在for i 的运行中的时候，i++都是可以理解为是在loop中基于i的操作完成了之后再进行的</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">++i</code> will increment the value of <code class="language-plaintext highlighter-rouge">i</code>, and <strong>then return the incremented value.</strong></li>
</ul>

<h3 id="java-mapentryk-v">[Java] Map.Entry&lt;k, v&gt;</h3>

<p>entry是一个类似键值对的接口，好像只能通过<code class="language-plaintext highlighter-rouge">AbstractMap.SimpleEntry(K k, V v);</code>去实例化，但这样子实例化似乎也没啥太大的意义。最大的意义在Map.entrySet()会返还一个entry的set，这样子可以使用foreach去access各个键值对，用</p>

<h3 id="java-priority-queue-in-reverse-order">[Java] Priority Queue in reverse order</h3>

<h3 id="code-sorting">[Code] Sorting</h3>

<h4 id="insertion-sort">Insertion Sort</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertionSortImplement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
  <span class="c1">//traverse整个array，把这当成没有sort好的那个array</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="c1">//tmp为目前要丢进sort好的arr中的那个元素</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

    <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
    <span class="c1">//接下来，我们遍历sort好的arr -&gt; 现在的结构：[- - - - | ^ - - -]，左边是sort好的</span>
    <span class="c1">//所以j要--</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
      <span class="c1">//当遇到比tmp大的值，就把他们向前移动一格</span>
      <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="c1">//把tmp插入到合适的位置</span>
    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以理解为要维护一个sort好的array，这个array一开始是空的，然后从没有sort好的arr中不停的抽取东西插进sort好的list中。</p>

<ol>
  <li>[] [4 2 3 1]</li>
  <li>[4] [2 3 1]</li>
  <li>[2 4] [3 1]</li>
  <li>[2 3 4] [1]</li>
  <li>[1 2 3 4] []</li>
</ol>

<p>原理就是这样，代码实现看代码</p>

<h4 id="merge-sort">Merge Sort</h4>

<ul>
  <li>算法：split，sort，merge</li>
  <li>每次在写的时候不要犯下一些莫名其妙的小错误</li>
  <li>优点是不管原始的数组多么的乱，排序的效率都是恒定的$O(nlogn)$；缺点就是需要重复的利用新的数组来存放排好序的数组，所以很浪费空间</li>
</ul>

<h4 id="quick-sort">Quick Sort</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">quickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">){</span>
        <span class="c1">//选择数组的最后一个作为pivot</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>
      	<span class="c1">//此时的i可以看作是一直指向最左边的比pivot大的元素</span>
      	<span class="c1">//j扫过整个arr，是一个希望找到比pivot小，能和i指向的位置替换的元素的指针</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="n">i</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">quickSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其实最主要的思想就是：在每一步，快排选择一个值作为pivot，然后把所有比他小的元素放到pivot的左边，把所有比他大的元素放到pivot的右边，然后再分别排序在pivot左边和右边的arr</p>

<p><a href="#目录">回到目录</a></p>

<h3 id="硬背">硬背</h3>
<h4 id="java-primitive-type-and-space">Java Primitive type and space</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Data Type</th>
      <th style="text-align: left">Size</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">byte</td>
      <td style="text-align: left">1 byte</td>
      <td style="text-align: left">Stores whole numbers from -128 to 127</td>
    </tr>
    <tr>
      <td style="text-align: left">short</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">Stores whole numbers from -32,768 to 32,767</td>
    </tr>
    <tr>
      <td style="text-align: left">int</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">Stores whole numbers from -2,147,483,648 to 2,147,483,647</td>
    </tr>
    <tr>
      <td style="text-align: left">long</td>
      <td style="text-align: left">8 bytes</td>
      <td style="text-align: left">Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
    </tr>
    <tr>
      <td style="text-align: left">float</td>
      <td style="text-align: left">4 bytes</td>
      <td style="text-align: left">Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits</td>
    </tr>
    <tr>
      <td style="text-align: left">double</td>
      <td style="text-align: left">8 bytes</td>
      <td style="text-align: left">Stores fractional numbers. Sufficient for storing 15 decimal digits</td>
    </tr>
    <tr>
      <td style="text-align: left">boolean</td>
      <td style="text-align: left">1 bit</td>
      <td style="text-align: left">Stores true or false values</td>
    </tr>
    <tr>
      <td style="text-align: left">char</td>
      <td style="text-align: left">2 bytes</td>
      <td style="text-align: left">Stores a single character/letter or ASCII values</td>
    </tr>
  </tbody>
</table>

<h4 id="模版mergesort">模版：mergeSort</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">){</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">){</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//deal with lhs</span>
  <span class="n">mergeSort</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
  <span class="c1">//deal with rhs</span>
  <span class="n">mergeSort</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
  <span class="c1">//merge</span>
  <span class="n">merge</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">temp</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="no">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">){</span>
  <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">leftIndex</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">rightIndex</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">leftIndex</span> <span class="o">&lt;=</span> <span class="n">middle</span> <span class="o">&amp;&amp;</span> <span class="n">rightIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="no">A</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">])</span> <span class="o">{</span>
      <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">++];</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
      <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">++];</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">leftIndex</span> <span class="o">&lt;=</span> <span class="n">middle</span><span class="o">){</span>
    <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">++];</span>
  <span class="o">}</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">rightIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">){</span>
    <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="no">A</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">++];</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
    <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="待补充">待补充</h3>

<h4 id="olog_fn">$O(log_{f}N)$</h4>

<h4 id="sorting-1">Sorting</h4>

<h4 id="java-regex-1">Java Regex</h4>

<h4 id="java-pointer">Java Pointer</h4>

<p><a href="#目录">回到目录</a></p>


</article>

<div class="page-navigation code">
	
		<a class="home" href="http://localhost:4000/" title="Back to Index">Index</a>
  
		<span> &middot; </span>
    <a class="prev" href="http://localhost:4000/m1-mac-install-risc-v-xv6" title="PREV: M1 Mac Install risc-v, qemu and xv6">&gt;&gt;</a>
  
</div>

<!-- Link Gitalk 的支持文件  -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<script type="text/javascript" src="/assets/js/md5.min.js"></script>
<div id="gitalk-container"></div>     
<script type="text/javascript">
    var gitalk = new Gitalk({
    // gitalk的主要参数
        clientID: 'f075f01270dae871aa15',
        clientSecret: '5a97f06edaad9527cb4a92d6d1ee12a86ec73057',
        repo: 'michaeltaoma.github.io',
        owner: 'michaeltaoma',
        admin: ['michaeltaoma'],
        id: md5(location.pathname),
        
    });
    gitalk.render('gitalk-container');
</script> 
<!-- Gitalk end -->


		</div>

		<div class="footer">
  <span class="block">&copy; 2022 Tao Ma</span>
  <!-- <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> -->
</div>


	</body>

</html>
